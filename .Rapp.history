data(BCI)#
## Accumulation model#
pool <- poolaccum(BCI)#
summary(pool, display = "chao")#
plot(pool)
head(BCI[1:5,])
head(BCI)
dim(BCI)
cumsum(dat$new.participant)
976/8818
plot(dat$new.participant)
220/11000
as.Date("23-November-2016")
as.Date("2016-November-23")
?as.Date
as.Date("2016-11-23")
head(dat)
as.Date("2017-1-18")-as.Date("2016-11-23")
dim(dat)
6390/56
expect <- rnorm(mean=40, sd=15, n=1000)
hist(expect)
hist(expect, xlab="Expected Hairy-Downy interactions", xlim=c(0,100))
hist(expect, xlab="Expected Hairy-Downy interactions", xlim=c(0,100), breaks=20)
hist(expect, xlab="Expected Hairy-Downy interactions", xlim=c(0,100), breaks=20, col="yellow")
hist(expect, xlab="Expected Hairy-Downy interactions", xlim=c(0,100), breaks=20, col=383)
hist(expect, xlab="Expected Hairy-Downy interactions", xlim=c(0,100), breaks=20, col=382)
hist(expect, xlab="Expected Hairy-Downy interactions", xlim=c(0,100), breaks=20, col=383)
hist(expect, xlab="Expected Hairy-Downy interactions", xlim=c(0,100), breaks=20, col="burlywood1")
hist(expect, xlab="Expected Hairy-Downy interactions", xlim=c(0,100), breaks=20, col="burlywood1", main="")
hist(expect, xlab="Expected Hairy-Downy interactions", xlim=c(0,100), breaks=20, col="burlywood1", main="", cex.lab=2)
hist(expect, xlab="Expected Hairy-Downy interactions", xlim=c(0,100), breaks=20, col="burlywood1", main="", cex.lab=1.4)
abline(v=2)
hist(expect, xlab="Expected Hairy-Downy interactions", xlim=c(0,100), breaks=20, col="burlywood1", main="", cex.lab=1.4)
abline(v=2, lwd=3, lty=2, col="red")
hist(expect, xlab="Expected Hairy-Downy interactions", xlim=c(0,100), breaks=20, col="burlywood1", main="", cex.lab=1.4)
abline(v=2, lwd=3, lty=2, col="red")
###########################################################################################
################################# Start libraries #########################################
###########################################################################################
#
library(jsonlite)#
library(igraph)#
library(addTaxa)#
library(viridis)#
library(statnet) #
library(dplyr)#
library(caper)#
library(BradleyTerry2)
library(igraph)#
#
unaltered <- graph.data.frame(data.frame(source=c("A","A","A","B","B","B","A"),#
	target=c("B","B","B","A","A","C","C")))#
#
networkSimplifier <- function(sub.graph, cutoff, conservative)#
{#
	#convert the graph into an adjacency matrix#
	adj <- get.adjacency(sub.graph)#
	#find the total number of each interspecific interaction. there is no reason on my#
	#personal computer to convert adj to a matrix below, but for some reason it fails on#
	#the cluster when transposing it, and doing this makes that not happen#
	totals <- adj + t(as.matrix(adj))#
	#find the proportions of interactions each species wins. set all NaN elements to 0.#
	#have to convert briefly to a matrix because can't seem to subset the S4 adjacency#
	#matrix properly for nan#
	props <- adj/totals#
	props <- as.matrix(props)#
	props[is.nan(props)] <- 0	#
	#for each element [i,j], find element [j,i]. #
	for(i in 1:dim(adj)[1])#
	{#
		for(j in 1:dim(adj)[1])#
		{#
			#if the element is 0, leave it as is and skip to next element#
			if(props[i,j] == 0)#
			{#
				adj[i,j] <- 0#
				next#
			}#
			#if conservative is TRUE and the element is less than or equal to the cutoff,#
			#set it to 0#
			else if(conservative==TRUE & props[i,j] <= cutoff)#
			{#
				adj[i,j] <- 0#
				next#
			}#
#
			#if conservative is TRUE and the element is greater than the#
			#cutoff, set it to 1#
			else if(conservative==TRUE & props[i,j] > cutoff)#
			{#
				adj[i,j] <- 1#
				next#
			}#
#
			#if conservative is FALSE and the element is greater than or equal to the#
			#cutoff, set it to 1#
			else if(conservative==FALSE & props[i,j] >= cutoff)#
			{#
				adj[i,j] <- 1#
				next#
			}#
#
			#this is the tricky part. if conservative is FALSE, and neither species is#
			#above the cutoff, than we want to set both to 1s. if one species is above the#
			#cutoff, than we want to set it to 1 and the other to 0. so if props[i,j] is#
			#less than the cutoff AND greater than or equal to 1-cutoff, set to 1#
			else if(conservative==FALSE & props[i,j] < cutoff & props[i,j] >= 1-cutoff)#
			{#
				adj[i,j] <- 1#
				next#
			}#
#
			#if props[i,j] is less than the cutoff AND less than 1-cutoff, set to 0#
			else if(conservative==FALSE & props[i,j] < cutoff & props[i,j] < 1-cutoff)#
			{#
				adj[i,j] <- 0#
				next#
			}#
#
			else#
			{#
				stop("You did something wrong")#
			}#
		}#
	}#
	#convert to a graph and return#
	toReturn <- graph_from_adjacency_matrix(adj)#
	toReturn#
}#
#
T.5 <- networkSimplifier(unaltered, 0.5, TRUE)#
T.9 <- networkSimplifier(unaltered, 0.9, TRUE)#
F.5 <- networkSimplifier(unaltered, 0.5, FALSE)#
F.9 <- networkSimplifier(unaltered, 0.9, FALSE)#
#
positions <- matrix(nrow=3, ncol=2, c(0,0.5,1,0,sqrt(1-0.25),0))#
#
m <- matrix(ncol=2, nrow=2, 1:4, byrow=TRUE)#
#
layout(mat=m)#
#
plot(T.5, layout=positions, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=75, vertex.label.cex=2.5, margin=-0.1)#
#
plot(T.9, layout=positions, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=75, vertex.label.cex=2.5, margin=-0.1)#
#
plot(F.5, layout=positions, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=75, vertex.label.cex=2.5, margin=-0.1)#
#
plot(F.9, layout=positions, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=75, vertex.label.cex=2.5, margin=-0.1)#
#
#close window and then plot this one#
#
plot(unaltered, layout=positions,#
	edge.curved=c(0.6,0.4,0.2,0.4,0.6,0,0), edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=75, vertex.label.cex=4)#
#and here are how to make the schematics showing different kinds of dominance hierarchies
linear <- graph.data.frame(data.frame(source=c("A","A","B"),#
	target=c("B","C","C"))
linear <- graph.data.frame(data.frame(source=c("A","A","B"),#
	target=c("B","C","C")))
plot(linera)
plot(linear)
positions <- matrix(nrow=3, ncol=2, c(0,0,0,1,2,3)#
#
plot(linear, layout=positions)
positions <- matrix(nrow=3, ncol=2, c(0,0,0,1,2,3))
positions
plot(linear, layout=positions)
plot(linear, layout=positions, curved=TRUE)
plot(linear, layout=positions, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=75, vertex.label.cex=2.5, margin=-0.1)
plot(linear, layout=positions, edge.curved=TRUE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=75, vertex.label.cex=2.5, margin=-0.1)
plot(linear, layout=positions, edge.curved=TRUE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=10, vertex.label.cex=2.5, margin=-0.1)
linear
plot(linear)
plot(linear, edge.curved=TRUE)
plot(linear, layout=positions, edge.curved=TRUE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=10, vertex.label.cex=1)
positions <- matrix(nrow=3, ncol=2, c(1,1,1,3,2,1))#
#
plot(linear, layout=positions, edge.curved=TRUE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=10, vertex.label.cex=1)
plot(linear, layout=positions, edge.curved=TRUE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=20, vertex.label.cex=1)
plot(linear, layout=positions, edge.curved=TRUE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=75, vertex.label.cex=4)
plot(linear, layout=positions, edge.curved=TRUE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=30, vertex.label.cex=4)
plot(linear, layout=positions, edge.curved=TRUE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=40, vertex.label.cex=4)
plot(linear, layout=positions, edge.curved=TRUE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=40, vertex.label.cex=2)
corporative <- graph.data.frame(data.frame(source=c("A","A","A","B","C"),#
	target=c("B","C","D","D","D")))
plot(corporative)
positions <- matrix(nrow=4, ncol=2, c(2,3,1,2,3,2,2,1))
positions
plot(corporative, layout=positions, edge.curved=TRUE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=30, vertex.label.cex=4)
plot(corporative, layout=positions, edge.curved=FALSE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=30, vertex.label.cex=4)
plot(linear, layout=positions, edge.curved=TRUE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=30, vertex.label.cex=2)
positions <- matrix(nrow=3, ncol=2, c(1,1,1,3,2,1))#
#
plot(linear, layout=positions, edge.curved=TRUE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=30, vertex.label.cex=2)
positions <- matrix(nrow=4, ncol=2, c(2,3,1,2,3,2,2,1))#
#
plot(corporative, layout=positions, edge.curved=FALSE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=30, vertex.label.cex=2)
positions <- matrix(nrow=4, ncol=2, c(2,2.5,1.5,2,3,2,2,1))#
#
plot(corporative, layout=positions, edge.curved=FALSE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=30, vertex.label.cex=2)
positions <- matrix(nrow=4, ncol=2, c(2,2.2,1.8,2,3,2,2,1))#
#
plot(corporative, layout=positions, edge.curved=FALSE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=30, vertex.label.cex=2)
positions <- matrix(nrow=4, ncol=2, c(2,2,2,2,3,2,2,1))#
#
plot(corporative, layout=positions, edge.curved=FALSE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=30, vertex.label.cex=2)
positions <- matrix(nrow=4, ncol=2, c(2,2.1,1.9,2,3,2,2,1))#
#
plot(corporative, layout=positions, edge.curved=FALSE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=30, vertex.label.cex=2)
positions
positions <- matrix(nrow=4, ncol=2, c(2,3,1,2,3,2,2,1))#
#
plot(corporative, layout=positions, edge.curved=FALSE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=30, vertex.label.cex=2)
positions <- matrix(nrow=4, ncol=2, c(2,4,0,2,3,2,2,1))#
#
plot(corporative, layout=positions, edge.curved=FALSE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=30, vertex.label.cex=2)
positions <- matrix(nrow=4, ncol=2, c(2,2,2,2,3,2,2,1))#
#
plot(corporative, layout=positions, edge.curved=FALSE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=30, vertex.label.cex=2)
positions <- matrix(nrow=4, ncol=2, c(2,3,1,2,3,2,2,1))#
#
plot(corporative, layout=positions, edge.curved=FALSE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=30, vertex.label.cex=2)
despotic <- graph.data.frame(data.frame(source=c("A","A","A"),#
	target=c("B","C","D")))
plot(despotic)
positions <- matrix(nrow=4, ncol=2, c(2,1,2,3,3,2,2,2))
positions
plot(despotic, layout=positions, edge.curved=FALSE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=30, vertex.label.cex=2)
positions <- matrix(nrow=4, ncol=2, c(2,1,2,3,2,1,1,1))#
#
plot(despotic, layout=positions, edge.curved=FALSE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=30, vertex.label.cex=2)
positions <- matrix(nrow=4, ncol=2, c(2,1,2,3,2,1.5,1.5,1.5))#
#
plot(despotic, layout=positions, edge.curved=FALSE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=30, vertex.label.cex=2)
positions <- matrix(nrow=4, ncol=2, c(2,1,2,3,2,1,1,1))#
#
plot(despotic, layout=positions, edge.curved=FALSE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=30, vertex.label.cex=2)
linear <- graph.data.frame(data.frame(source=c("A","A","B"),#
	target=c("B","C","C")))#
#
positions <- matrix(nrow=3, ncol=2, c(1,1,1,3,2,1))#
#
plot(linear, layout=positions, edge.curved=TRUE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=30, vertex.label.cex=2)
linear <- graph.data.frame(data.frame(source=c("A","A","B"),#
	target=c("B","C","C")))#
#
positions <- matrix(nrow=3, ncol=2, c(1,1,1,3,2,1))#
#
plot(linear, layout=positions, edge.curved=TRUE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=40, vertex.label.cex=2)
corporative <- graph.data.frame(data.frame(source=c("A","A","A","B","C"),#
	target=c("B","C","D","D","D")))#
#
positions <- matrix(nrow=4, ncol=2, c(2,3,1,2,3,2,2,1))#
#
plot(corporative, layout=positions, edge.curved=FALSE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=40, vertex.label.cex=2)
despotic <- graph.data.frame(data.frame(source=c("A","A","A"),#
	target=c("B","C","D")))#
#
positions <- matrix(nrow=4, ncol=2, c(2,1,2,3,2,1,1,1))#
#
plot(despotic, layout=positions, edge.curved=FALSE, edge.arrow.size=1.2, edge.color="black",#
	vertex.label.color="black", vertex.color="white", vertex.label.family="sans",#
	vertex.size=40, vertex.label.cex=2)
library(doParallel)#
#
exFun <- function(av1, std1, av2, std2, cores)#
{#
		registerDoParallel(cores)#
#
		thing1 <- rnorm(n=10, mean=av1, sd=std1)#
#
		thing2 <- rnorm(n=10, mean=av2, sd=std2)#
#
		results <- list(result1=thing1, result2=thing2)#
}
exFun(1, 1, 2, 2)
library(doParallel)#
#
exFun <- function(av1, std1, av2, std2, cores)#
{#
		registerDoParallel(cores)#
#
		thing1 <- rnorm(n=10, mean=av1, sd=std1)#
#
		thing2 <- rnorm(n=10, mean=av2, sd=std2)#
#
		results <- list(result1=thing1, result2=thing2)#
#
		results#
}
exFun(1, 1, 2, 2)
?rnorm
exFun <- function(av1, std1, av2, std2, iterations, cores)#
{#
		registerDoParallel(cores)#
#
		thing1 <- rnorm(n=10, mean=av1, sd=std1)#
#
		thing2 <- foreach(i = 1:iterations) %dopar%#
		{#
			rnorm(n=10, mean=av2, sd=std2)#
		}#
#
		results <- list(result1=thing1, result2=thing2)#
#
		results#
}
exFun(1, 1, 2, 2, 10, 4)
system.time(test <- exFun(av1=0, std1=1, av2=100, std2=10, iterations=1000, cores=2))
str(test)
str(test,2)
system.time(test <- exFun(av1=0, std1=1, av2=100, std2=10, iterations=1000, cores=1))#
system.time(test <- exFun(av1=0, std1=1, av2=100, std2=10, iterations=1000, cores=2))
system.time(test <- exFun(av1=0, std1=1, av2=100, std2=10, iterations=1000, cores=1))#
system.time(test <- exFun(av1=0, std1=1, av2=100, std2=10, iterations=1000, cores=2))#
system.time(test <- exFun(av1=0, std1=1, av2=100, std2=10, iterations=1000, cores=8))
str(test)
str(test,3)
str(test,4)
?str
system.time(test <- exFun(av1=0, std1=1, av2=100, std2=10, iterations=100000, cores=1))#
system.time(test <- exFun(av1=0, std1=1, av2=100, std2=10, iterations=100000, cores=8))
as.Date("2015-June-13")
as.Date("2015-Jun-13")
library(anydate)
library(anytime)
anydate("2015-Jun-13")
anydate("2017-Feb-01")-anydate("2015-Jun-13")
library(metricTester)
?metricsNnulls
tree <- geiger::sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1#
#
cdm <- simulateComm(tree, richness.vector=10:25, abundances=sim.abundances)#
#
rawResults <- metricsNnulls(tree, cdm, randomizations=3, metrics="mntd",#
nulls=c("richness", "frequency"))
defineMetrics()
tree <- geiger::sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1#
#
cdm <- simulateComm(tree, richness.vector=10:25, abundances=sim.abundances)#
#
rawResults <- metricsNnulls(tree, cdm, randomizations=3, metrics="NAW_MNTD",#
nulls=c("richness", "frequency"))
rawResults
?summaries
?sesOverall
#simulate a phylogenetic tree with birth-death process. although not needed for this#
#example per se, many metricTester functions anticipate a tree, and it's often easier to#
#just create one and pass it along#
tree <- geiger::sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
#simulate a log-normal abundance distribution#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1#
#
#sample from that distribution to create a community data matrix of varying species #
#richness#
cdm <- simulateComm(tree, richness.vector=10:25, abundances=sim.abundances)#
#
#define a new metric. here we will simply calculate the total abundance (i.e. the total#
#number of individuals of any species) per plot.#
tempMetric <- function(input.vector)#
{#
    nonZeros <- input.vector[input.vector != 0]#
    return(sum(nonZeros))#
}#
#
#write a quick wrapper to apply the new metric over a community data matrix. note that the #
#metrics in metricTester expect a prepped object of class metrics.input. downstream#
#functions are going to convert your inputs into a prepped metrics.input object, then the#
#function is going to run over the $picante.cdm element within the prepped metrics.input#
#object. ensure the metric is calculated over this $picante.cdm element#
dummyMetric <- function(metrics.input)#
{#
    results <- apply(metrics.input$picante.cdm, 1, tempMetric)#
    results#
}#
#
#define a new null model. here we will simply completely shuffle the contents of the#
#community data matrix. like the above, your inputs will be automatically converted into#
#a prepped object of nulls.input. so, make sure the null model runs over #
#nulls.input$picante.cdm#
dummyNull <- function(nulls.input)#
{#
    results <- matrix(nrow=dim(nulls.input$picante.cdm)[1],#
    ncol=dim(nulls.input$picante.cdm)[2], sample(unlist(nulls.input$picante.cdm)))#
    rownames(results) <- row.names(nulls.input$picante.cdm)#
    colnames(results) <- names(nulls.input$picante.cdm)#
    results#
}#
#
#see what we expect plot-level total abundance to be after repeatedly randomizing the#
#matrix 100 times. note that metricTester always expects richness to be included, so this#
#example wouldn't work if we did not include it as a metric.#
expectations(tree=tree, picante.cdm=cdm, nulls=list("fullShuffle"=dummyNull),#
metrics=list("richness"=metricTester:::my_richness, "totalAbund"=dummyMetric),#
randomizations=100, concat.by="plot", cores=8)
?expectations
tree <- geiger::sim.bdtree(b=0.1, d=0, stop="taxa", n=50)#
#
#simulate a log normal abundance distribution#
sim.abundances <- round(rlnorm(5000, meanlog=2, sdlog=1)) + 1#
#
#simulate a community of varying richness#
cdm <- simulateComm(tree, richness.vector=10:13, abundances=sim.abundances)#
#
#below not run for timing issues on CRAN#
test <- expectations(picante.cdm=cdm, tree=tree, optional.dists=NULL,#
regional.abundance=NULL, distances.among=NULL, randomizations=3, cores="seq",#
nulls="richness", metrics=c("richness", "NAW_MPD"),#
concat.by="both", output.raw=FALSE)
test
?mntd
?ses.mntd
800*5
800*5/60
29/786
100/29/786
100/(29/786)
100/(29/786)*3
100/0.03
786/29
27*3
1020/4
956/4
remove.packages("ROracle")
library(ROracle)
remove.packages("ROracle")
library(ROracle)
Sys.getenv("DYLD_LIBRARY_PATH")
Sys.getenv("PATH")
Sys.which("pdflatex")
paste(aa,"R/R-2.12.1/bin/i386",sep="")
aa<- strsplit(R.home(),"R")[[1]][1]
aa
Sys.setenv("DYLD_LIBRARY_PATH"="/Users/eliotmiller/scratch/instantclient_12_1")
library(ROracle)
Sys.getenv("DYLD_LIBRARY_PATH")
Sys.setenv("DYLD_LIBRARY_PATH"="/Users/eliotmiller/scratch/")
Sys.getenv("DYLD_LIBRARY_PATH")
library(ROracle)
Sys.getenv("DYLD_LIBRARY_PATH")
library(ROracle)
library(metricTester)
?metricsNnulls
defineMetrics()
120*3
360/2
120*1000
120*1000/2
library(devtools)
install_github("l1ou", username="khabbazian")
install_github("l1ou", username="khabbazian", force=TRUE)
picante::psc()
picante::psc
library(picante)
sessionInfo()
gam
??te
library(mgcv)
data(trees)
ls()
head(trees)
ct6 <- gam(Volume~te(Height,Girth,k=5),family=Gamma(link=log),data=trees)
ct6
plot(ct6)
?te
25*7.5
#this script will prep Ben's crow-raven inputs for and then run a GAM#
#
library(data.table)#
library(anytime)#
library(mgcv)#
#
#bring in the confirmed crow-raven interactions#
cr <- read.csv("CrowVsRaven_2017.01.31.csv")#
#
#there is something screwed up with the aggressor column#
cr$AGGRESSOR[grep("crow", cr$AGGRESSOR)] <- "crow"#
#
#subset this to attacks of crows on ravens#
cr <- cr[cr$COMMON.NAME %in% c("Common Raven", "American Crow")#
	& cr$AGGRESSOR=="crow",]#
#
#now bring in the total comment data sheet#
totalC <- fread("commentsDF.csv")#
totalC <- as.data.frame(totalC)#
#
#subset this datasheet to just American Crow or Common Raven obs#
basicData <- totalC[totalC$COMMON.NAME %in% c("Common Raven", "American Crow"),]#
basicData$date <- anydate(basicData$OBSERVATION.DATE)#
#
#get the julian date for these dates#
basicData$julian <- yday(basicData$date)#
#
#now set up the start of the file to use for the GAM#
forModel <- data.frame(id=basicData$GLOBAL.UNIQUE.IDENTIFIER,#
	latitude=basicData$LATITUDE, day=basicData$julian, attack=0)
1461*2
1052*2
2104*2922
2104+2922
?bs
??bs
library(aniDom)#
library(doBy)#
library(dplyr)#
library(compete)#
library(BradleyTerry2)#
# Clear memory#
rm(list=ls())#
#playing around#
#
ptm <- proc.time()#
avalues <- c(30)#
bvalues <- c(5)#
N.inds.values <- c(112)#
Nits <- c(3636)#
poiss <- c(TRUE)#
dombias <- c(FALSE)#
#creating empty database#
db <- data.frame(Ninds=integer(),#
                 Nits=integer(),#
                 poiss=logical(),#
                 dombias=logical(),#
                 alevel=integer(),#
                 blevel=integer(),#
                 spearman=numeric(),#
                 BTspearman=numeric(),#
                 unknowndyads=numeric(),#
                 ttri=numeric(),#
                 pval=numeric(),#
                 stringsAsFactors=FALSE)#
for (typ in 1:length(poiss)){#
  for (i in 1:length(bvalues)){#
    for (j in 1:length(avalues)){#
      for (p in 1:length(N.inds.values)){#
        for (simnum in 1:1){#
          output <- generate_interactions(N.inds.values[p],#
                                          Nits[p],#
                                          a=avalues[j],#
                                          b=bvalues[i],#
                                          id.biased=poiss[typ],#
                                          rank.biased=dombias[typ])#
          winner <- output$interactions$Winner#
          loser <- output$interactions$Loser#
          hierarchy <- output$hierarchy#
          # generating sociomatrix and estimating number of #
          # unknown relationships and Ttri#
          matrix<-get_wl_matrix(output$interactions)#
          unknowndyads<-rshps(matrix)$unknowns/rshps(matrix)$total#
          ttri<-ttri_test(matrix)$ttri#
          pval<-ttri_test(matrix)$pval#
          #randomized Elo-rating#
#
          result <- elo_scores(winner,#
                                loser,#
                                identities=c(1:N.inds.values[p]),#
                                init.score=1000,#
                                randomise=TRUE,#
                                return.as.ranks=TRUE)#
          mean.scores <- rowMeans(result)#
          spearman.cor<-cor(output$hierarchy$Rank,#
                             mean.scores,#
                             use="complete.obs",method="spearman")#
          #Bradley-Terry model trial#
          intBT <- countsToBinomial(matrix)#
          BTmodel <- BTm(cbind(win1, win2), player1, player2, ~ player,#
                         id = "player", data = intBT)#
          w<-sort(BTmodel$coefficients)#don't get why there is one individual missing from coefficients#
          z <- data.frame(w,attributes(w),#
                          row.names = as.character(seq(1,length(w),#
                                                       1)))#
          z$rank <- as.numeric(substr(z$name,7,9))#
          z$BTO.ranked <- rank(-z$w,na.last="keep")#
          BTspearman<-cor(z$rank,z$BTO.ranked,#
                          use="complete.obs",method="spearman")#
          #adding values to db#
          db<-rbind(db,c(N.inds.values[p],Nits[p],#
                         poiss[typ],dombias[typ],#
                         avalues[j],bvalues[i],#
                         spearman.cor,#
                         BTspearman,#
                         unknowndyads,#
                         ttri,#
                         pval))#
        }        #
      }#
    }#
  }#
  #renaming variables in database#
  names(db) <- c("Ninds","Nits",#
                 "poiss","dombias",#
                 "alevel","blevel",#
                 "spearman",#
                 "BTspearman",#
                 "unknowndyads",#
                 "ttri",#
                 "pval")#
}
install.packages("compete")
rm(list=ls())
library(aniDom)#
library(doBy)#
library(dplyr)#
library(compete)#
library(BradleyTerry2)#
# Clear memory#
rm(list=ls())#
#playing around#
#
ptm <- proc.time()#
avalues <- c(30)#
bvalues <- c(5)#
N.inds.values <- c(112)#
Nits <- c(3636)#
poiss <- c(TRUE)#
dombias <- c(FALSE)#
#creating empty database#
db <- data.frame(Ninds=integer(),#
                 Nits=integer(),#
                 poiss=logical(),#
                 dombias=logical(),#
                 alevel=integer(),#
                 blevel=integer(),#
                 spearman=numeric(),#
                 BTspearman=numeric(),#
                 unknowndyads=numeric(),#
                 ttri=numeric(),#
                 pval=numeric(),#
                 stringsAsFactors=FALSE)#
for (typ in 1:length(poiss)){#
  for (i in 1:length(bvalues)){#
    for (j in 1:length(avalues)){#
      for (p in 1:length(N.inds.values)){#
        for (simnum in 1:1){#
          output <- generate_interactions(N.inds.values[p],#
                                          Nits[p],#
                                          a=avalues[j],#
                                          b=bvalues[i],#
                                          id.biased=poiss[typ],#
                                          rank.biased=dombias[typ])#
          winner <- output$interactions$Winner#
          loser <- output$interactions$Loser#
          hierarchy <- output$hierarchy#
          # generating sociomatrix and estimating number of #
          # unknown relationships and Ttri#
          matrix<-get_wl_matrix(output$interactions)#
          unknowndyads<-rshps(matrix)$unknowns/rshps(matrix)$total#
          ttri<-ttri_test(matrix)$ttri#
          pval<-ttri_test(matrix)$pval#
          #randomized Elo-rating#
#
          result <- elo_scores(winner,#
                                loser,#
                                identities=c(1:N.inds.values[p]),#
                                init.score=1000,#
                                randomise=TRUE,#
                                return.as.ranks=TRUE)#
          mean.scores <- rowMeans(result)#
          spearman.cor<-cor(output$hierarchy$Rank,#
                             mean.scores,#
                             use="complete.obs",method="spearman")#
          #Bradley-Terry model trial#
          intBT <- countsToBinomial(matrix)#
          BTmodel <- BTm(cbind(win1, win2), player1, player2, ~ player,#
                         id = "player", data = intBT)#
          w<-sort(BTmodel$coefficients)#don't get why there is one individual missing from coefficients#
          z <- data.frame(w,attributes(w),#
                          row.names = as.character(seq(1,length(w),#
                                                       1)))#
          z$rank <- as.numeric(substr(z$name,7,9))#
          z$BTO.ranked <- rank(-z$w,na.last="keep")#
          BTspearman<-cor(z$rank,z$BTO.ranked,#
                          use="complete.obs",method="spearman")#
          #adding values to db#
          db<-rbind(db,c(N.inds.values[p],Nits[p],#
                         poiss[typ],dombias[typ],#
                         avalues[j],bvalues[i],#
                         spearman.cor,#
                         BTspearman,#
                         unknowndyads,#
                         ttri,#
                         pval))#
        }        #
      }#
    }#
  }#
  #renaming variables in database#
  names(db) <- c("Ninds","Nits",#
                 "poiss","dombias",#
                 "alevel","blevel",#
                 "spearman",#
                 "BTspearman",#
                 "unknowndyads",#
                 "ttri",#
                 "pval")#
}
plot_winner_prob(1:112,a=30,b=5) #possible hierarchy shape
db <- read.table("FeederWatch_40sim.csv",header=TRUE,sep=",")
getwd()
library(igraph)#
library(BradleyTerry2)#
library(aniDom)#
library(EloRating)
install.packages("metricTester")
makeRoadMap
library(metricTester)
makeRoadMap
1/160
1/160*360
(1/160)*360
80*6.2
80/6.2
45*3.50
library(geiger)
sal=get(data(caudata))res=congruify.phylo(sal$fam, sal$phy, sal$tax, tol=0, scale=NA, ncores=2) print(res$calibrations)plot(ladderize(sal$phy,right=FALSE), cex=0.35, type="fan", label.offset=2.5) plot(ladderize(sal$fam,right=FALSE), cex=0.5, type="fan", label.offset=2.5, no.margin=FALSE)
res=congruify.phylo(sal$fam, sal$phy, sal$tax, tol=0, scale=NA, ncores=2)
print(res$calibrations)
plot(ladderize(sal$phy,right=FALSE), cex=0.35, type="fan", label.offset=2.5)
sal$fam
plot(sal$fam)
sal$phy
plot(res)
cat("\n\n\n*** If 'PATHd8' is installed ***, execute the following:    \n\tres=congruify.phylo(sal$fam, sal$phy, sal$tax, tol=0, scale=\"PATHd8\")    \tprint(res)    \n\tplot(res$phy, cex=0.35, type=\"fan\", label.offset=2.5)    \n\tprint(max(branching.times(res$phy)))    \tprint(max(branching.times(sal$fam)))    \tprint(max(branching.times(sal$phy)))\n\n\n")
res
plot(res$target)
??randomlyAddTaxa
library(randomlyAddTaxa)
library(addTaxa)
TreeSim
randomlyAddTaxa
bdScaler
?bdScaler
?corsim
ls()
queryList <- list("Ivory-billed Woodpecker"="ivbwoo")
queryList
queryList <- list("Ivory-billed Woodpecker"="ivbwoo", "Test"="dkdkd")
queryList
queryList <- list("Ivory-billed_Woodpecker"="ivbwoo", "Test"="dkdkd")
queryList
queryList <- list("Ivory-billed Woodpecker"="ivbwoo", "Red-did wood"="dkdkd")
queryList
9000/60
150/24
532/60
9*333/60
9*333
2997/60
3949/60
library(data.table)
fwrite(d)
library(devtools)
install.packages("data.table")
library(data.table)
fwrite()
??driver
library(data.table)
library(devtools)
load_all()
document()
